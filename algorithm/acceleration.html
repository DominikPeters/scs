
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Acceleration &#8212; SCS 3.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/scs_theme.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Relaxation" href="relaxation.html" />
    <link rel="prev" title="Warm-starting" href="warm_start.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="acceleration">
<span id="id1"></span><h1>Acceleration<a class="headerlink" href="#acceleration" title="Permalink to this headline"></a></h1>
<p>SCS includes Anderson acceleration (AA), which can be used to speed up
convergence. AA is a quasi-Newton method for the acceleration of fixed point
iterations and can dramatically speed up convergence in practice, especially if
higher accuracy solutions are desired. However, it can also cause severe
instability of the solver and so should be used with caution. It is an open
research question how to best implement AA in practice to ensure good
performance across all problems and we welcome any <a class="reference internal" href="../contributing/index.html#contributing"><span class="std std-ref">contributions</span></a> in that direction!</p>
<div class="section" id="mathematical-details">
<h2>Mathematical details<a class="headerlink" href="#mathematical-details" title="Permalink to this headline"></a></h2>
<p>The discussion here is taken from section 2 of our <a class="reference external" href="https://web.stanford.edu/~boyd/papers/nonexp_global_aa1.html">paper</a>.
Consider the problem of finding a fixed point of the function <span class="math notranslate nohighlight">\(f:
\mathbf{R}^n \rightarrow \mathbf{R}^n\)</span>, i.e.,</p>
<div class="math notranslate nohighlight">
\[\text{Find } x \in \mathbf{R}^n \text{ such that } x = f(x).\]</div>
<p>In our case <span class="math notranslate nohighlight">\(f\)</span> corresponds to one step of <a class="reference internal" href="index.html#algorithm"><span class="std std-ref">Douglas-Rachford
splitting</span></a> and the iterate is the <span class="math notranslate nohighlight">\(w^k\)</span> vector, which
converges to a fixed point of the DR operator. At a high level AA, from initial
point <span class="math notranslate nohighlight">\(x_0\)</span> and max memory <span class="math notranslate nohighlight">\(m\)</span> (corresponding to the
<code class="code docutils literal notranslate"><span class="pre">acceleration_lookback</span></code> setting), works as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{l}
\text{For } k=0, 1, \dots \\
\quad \text{Set } m_k=\min\{m, k\} \\
\quad \text{Select weights } \alpha_j^k \text{ based on the last } m_k \text{
  iterations satisfying } \sum_{j=0}^{m_k}\alpha_j^k=1 \\
\quad \text{Set } x^{k+1}=\sum_{j=0}^{m_k}\alpha_j^kf(x^{k-m_k+j})
\end{array}\end{split}\]</div>
<p>In other words, AA produces an iterate that is the linear combination of the
last <span class="math notranslate nohighlight">\(m_k + 1\)</span> outputs of the map.  Thus, the main challenge is in
choosing the weights <span class="math notranslate nohighlight">\(\alpha \in \mathbf{R}^{m_k+1}\)</span>. There are two ways
to choose them, corresponding to type-I and type-II AA (named for the type-I and
type-II Broyden updates). We shall present type-II first.</p>
<div class="section" id="type-ii-aa">
<h3>Type-II AA<a class="headerlink" href="#type-ii-aa" title="Permalink to this headline"></a></h3>
<p>Define the residual <span class="math notranslate nohighlight">\(g: \mathbf{R}^n \rightarrow \mathbf{R}^n\)</span> of
<span class="math notranslate nohighlight">\(f\)</span> to be <span class="math notranslate nohighlight">\(g(x) = x - f(x)\)</span>. Note that any fixed point
<span class="math notranslate nohighlight">\(x^\star\)</span> satisfies <span class="math notranslate nohighlight">\(g(x^\star) = 0\)</span>.
In type-II AA the weights are selected by solving a small least squares problem.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{ll}
\mbox{minimize} &amp; \|\sum_{j=0}^{m_k}\alpha_j g(x^{k-m_k+j})\|_2^2\\
\mbox{subject to} &amp; \sum_{j=0}^{m_k}\alpha_j=1,
\end{array}\end{split}\]</div>
<p>More explicitly, we can reformulate the above as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{array}{ll}
\mbox{minimize} &amp; \|g_k-Y_k\gamma\|_2,
\end{array}\]</div>
<p>with variable <span class="math notranslate nohighlight">\(\gamma=(\gamma_0,\dots,\gamma_{m_k-1}) \in
\mathbf{R}^{m_k}\)</span>. Here <span class="math notranslate nohighlight">\(g_i=g(x^i)\)</span>,
<span class="math notranslate nohighlight">\(Y_k=[y_{k-m_k}~\dots~y_{k-1}]\)</span> with <span class="math notranslate nohighlight">\(y_i=g_{i+1}-g_i\)</span> for each
<span class="math notranslate nohighlight">\(i\)</span>, and <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\gamma\)</span> are related by
<span class="math notranslate nohighlight">\(\alpha_0=\gamma_0\)</span>, <span class="math notranslate nohighlight">\(\alpha_i=\gamma_i-\gamma_{i-1}\)</span> for
<span class="math notranslate nohighlight">\(1\leq i\leq m_k-1\)</span> and <span class="math notranslate nohighlight">\(\alpha_{m_k}=1-\gamma_{m_k-1}\)</span>.</p>
<p>Assuming that <span class="math notranslate nohighlight">\(Y_k\)</span> is full column rank, the solution
<span class="math notranslate nohighlight">\(\gamma^k\)</span> to the above is given by <span class="math notranslate nohighlight">\(\gamma^k=(Y_k^\top
Y_k)^{-1}Y_k^\top g_k\)</span>, and hence by the relation between <span class="math notranslate nohighlight">\(\alpha^k\)</span> and
<span class="math notranslate nohighlight">\(\gamma^k\)</span>, the next iterate of type-II AA can be written as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
x^{k+1}&amp;=f(x^k)-\sum_{i=0}^{m_k-1}\gamma_i^k\left(f(x^{k-m_k+i+1})- f(x^{k-m_k+i})\right)\\
&amp;=x^k-g_k-(S_k-Y_k)\gamma^k\\
&amp;=x^k-(I+(S_k-Y_k)(Y_k^\top Y_k)^{-1}Y_k^\top )g_k\\
&amp;=x^k-B_kg_k,
\end{align}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(S_k=[s_{k-m_k}~\dots~s_{k-1}]\)</span>, <span class="math notranslate nohighlight">\(s_i=x^{i+1}-x^i\)</span> for each
<span class="math notranslate nohighlight">\(i\)</span>, and</p>
<div class="math notranslate nohighlight">
\[B_k=I+(S_k-Y_k)(Y_k^\top Y_k)^{-1}Y_k^\top\]</div>
<p>Observe that <span class="math notranslate nohighlight">\(B_k\)</span> minimizes <span class="math notranslate nohighlight">\(\|B_k-I\|_F\)</span> subject to
the inverse multi-secant condition <span class="math notranslate nohighlight">\(B_kY_k=S_k\)</span>, and hence can be regarded
as an approximate inverse Jacobian of <span class="math notranslate nohighlight">\(g\)</span>. The update of <span class="math notranslate nohighlight">\(x^k\)</span> can
then be considered as a quasi-Newton-type update, with <span class="math notranslate nohighlight">\(B_k\)</span> being
a generalized second (or type-II) Broyden’s update of <span class="math notranslate nohighlight">\(I\)</span> satisfying
the inverse multi-secant condition.</p>
</div>
<div class="section" id="type-i-aa">
<h3>Type-I AA<a class="headerlink" href="#type-i-aa" title="Permalink to this headline"></a></h3>
<p>In the same spirit, we define type-I AA, in which we find an approximate
Jacobian of <span class="math notranslate nohighlight">\(g\)</span> minimizing <span class="math notranslate nohighlight">\(\|H_k-I\|_F\)</span> subject to the multi-secant
condition <span class="math notranslate nohighlight">\(H_kS_k=Y_k\)</span>. Assuming that <span class="math notranslate nohighlight">\(S_k\)</span> is full column rank, we
obtain (by symmetry) that</p>
<div class="math notranslate nohighlight">
\[H_k=I+(Y_k-S_k)(S_k^\top S_k)^{-1}S_k^\top\]</div>
<p>and the update scheme is defined as</p>
<div class="math notranslate nohighlight">
\[x^{k+1}=x^k-H_k^{-1}g_k\]</div>
<p>assuming <span class="math notranslate nohighlight">\(H_k\)</span> to be invertible. A direct application of the Woodbury
matrix identity shows that</p>
<div class="math notranslate nohighlight">
\[H_k^{-1}=I+(S_k-Y_k)(S_k^\top Y_k)^{-1}S_k^\top\]</div>
<p>where again we have assumed that <span class="math notranslate nohighlight">\(S_k^\top Y_k\)</span> is invertible.  Notice
that this explicit formula of <span class="math notranslate nohighlight">\(H_k^{-1}\)</span> is preferred in that the most
costly step, inversion, is implemented only on a small <span class="math notranslate nohighlight">\(m_k\times m_k\)</span>
matrix.</p>
</div>
</div>
<div class="section" id="in-scs">
<h2>In SCS<a class="headerlink" href="#in-scs" title="Permalink to this headline"></a></h2>
<p>In SCS both types of acceleration are available, though by default type-I is
used since it tends to have better performance.  If you wish to enable AA then
set the <code class="code docutils literal notranslate"><span class="pre">acceleration_lookback</span></code> setting to a non-zero value (10 works well
for many problems). This setting corresponds to <span class="math notranslate nohighlight">\(m\)</span>, the maximum number of
SCS iterates that AA will use to extrapolate to the new point.</p>
<p>To enable type-II acceleration then set <code class="code docutils literal notranslate"><span class="pre">acceleration_lookback</span></code> to a
negative value, the sign is interpreted as switching the AA type (this is mostly
so that we can test it without fully exposing it the user).</p>
<p>The setting <code class="code docutils literal notranslate"><span class="pre">acceleration_interval</span></code> controls how frequently AA is applied.
If <code class="code docutils literal notranslate"><span class="pre">acceleration_interval</span></code> <span class="math notranslate nohighlight">\(=k\)</span> for some integer <span class="math notranslate nohighlight">\(k \geq 1\)</span>
then AA is applied every <span class="math notranslate nohighlight">\(k\)</span> iterations (AA simply ignores the
intermediate iterations). This has the benefit of making AA <span class="math notranslate nohighlight">\(k\)</span> times
faster and approximating a <span class="math notranslate nohighlight">\(k\)</span> times larger memory, as well as improving
numerical stability by ‘decorrelating’ the data. On the other hand, older
iterates might be stale.  More work is needed to determine the optimal setting
for this parameter, but 10 appears to work well in practice.</p>
<p>The details about how the linear systems are solved and updated is abstracted
away into the AA package (eg, QR decomposition, SVD decomposition etc). Exactly
how best to solve and update the equations is still open.</p>
<div class="section" id="regularization">
<h3>Regularization<a class="headerlink" href="#regularization" title="Permalink to this headline"></a></h3>
<p>By default we also add a small amount of regularization to the matrices
that are being inverted in the above expressions, ie, in the type-II update</p>
<div class="math notranslate nohighlight">
\[(Y_k^\top Y_k)^{-1} \text{ becomes } (Y_k^\top Y_k + \epsilon I)^{-1}\]</div>
<p>for some small <span class="math notranslate nohighlight">\(\epsilon &gt; 0\)</span>, and similarly for the type-I update</p>
<div class="math notranslate nohighlight">
\[(S_k^\top Y_k)^{-1} \text{ becomes } (S_k^\top Y_k + \epsilon I)^{-1}\]</div>
<p>which is equivalent to adding regularization to the <span class="math notranslate nohighlight">\(S_k^\top S_k\)</span> matrix
before using the Woodbury matrix identity.  The regularization ensures the
matrices are invertible and helps stability. In practice type-I tends to require
more regularization than type-II for good performance. The regularization
shrinks the AA update towards the update without AA, since if
<span class="math notranslate nohighlight">\(\epsilon\rightarrow\infty\)</span> then <span class="math notranslate nohighlight">\(\gamma^\star = 0\)</span> and the AA step
reduces to <span class="math notranslate nohighlight">\(x^{k+1} = f(x^k)\)</span>. Note that the regularization can be folded
into the matrices by appending <span class="math notranslate nohighlight">\(\sqrt{\epsilon} I\)</span> to the bottom of
<span class="math notranslate nohighlight">\(S_k\)</span> or <span class="math notranslate nohighlight">\(Y_k\)</span>, which is useful when using a QR or SVD decomposition
to solve the equations.</p>
</div>
<div class="section" id="max-gamma-norm">
<h3>Max <span class="math notranslate nohighlight">\(\gamma\)</span> norm<a class="headerlink" href="#max-gamma-norm" title="Permalink to this headline"></a></h3>
<p>As the algorithm converges to the fixed point the matrices to be inverted
can become ill-conditioned and AA can become unstable. In this case the
<span class="math notranslate nohighlight">\(\gamma\)</span> vector can become very large. As a simple heuristic we reject
the AA update and reset the AA state whenever <span class="math notranslate nohighlight">\(\|\gamma\|_2\)</span> is greater
than <code class="code docutils literal notranslate"><span class="pre">max_weight_norm</span></code> (eg, something very large like <span class="math notranslate nohighlight">\(10^{10}\)</span>).</p>
</div>
<div class="section" id="safeguarding">
<h3>Safeguarding<a class="headerlink" href="#safeguarding" title="Permalink to this headline"></a></h3>
<p>We also apply a safeguarding step to the output of the AA step. Explicitly, let
<span class="math notranslate nohighlight">\(x^k\)</span> be the current iteration and let <span class="math notranslate nohighlight">\(x_\mathrm{AA} = x^{k+1}\)</span> be
the output of AA. We reject the AA step if</p>
<div class="math notranslate nohighlight">
\[\|x_\mathrm{AA} - f(x_\mathrm{AA}) \|_2 &gt; \zeta \|x^k - f(x^k) \|_2\]</div>
<p>where <span class="math notranslate nohighlight">\(\zeta\)</span> is the safeguarding tolerance factor
(<code class="code docutils literal notranslate"><span class="pre">safeguard_factor</span></code>) and defaults to 1. In other words we reject the step
if the norm of the residual after the AA step is larger than some amount (eg, if
it increases the residual from the previous iterate).  After rejecting a step we
revert the iterate to <span class="math notranslate nohighlight">\(x^k\)</span> and reset the AA state.</p>
</div>
<div class="section" id="relaxation">
<h3>Relaxation<a class="headerlink" href="#relaxation" title="Permalink to this headline"></a></h3>
<p>In some works relaxation has been shown to improve performance. Relaxation
replaces the final step of AA by mixing the map inputs and outputs as follows:</p>
<div class="math notranslate nohighlight">
\[x^{k+1} = \beta \sum_{j=0}^{m_k}\alpha_j^k f(x^{k-m_k+j}) + (1-\beta) \sum_{j=0}^{m_k}\alpha_j^k x^{k-m_k+j}\]</div>
<p>where <span class="math notranslate nohighlight">\(\beta\)</span> is the <code class="code docutils literal notranslate"><span class="pre">relaxation</span></code> parameter, and <span class="math notranslate nohighlight">\(\beta=1\)</span>
recovers vanilla AA. This can be computed using the matrices defined above using</p>
<div class="math notranslate nohighlight">
\[x^{k+1} = \beta (f(x^k) - (S_k - Y_k) \gamma^k) + (1-\beta) (x^k - S_k \gamma^k)\]</div>
</div>
</div>
<div class="section" id="anderson-acceleration-api">
<h2>Anderson acceleration API<a class="headerlink" href="#anderson-acceleration-api" title="Permalink to this headline"></a></h2>
<p>For completeness, we document the full Anderson acceleration API below.</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv48aa_float">
<span id="_CPPv38aa_float"></span><span id="_CPPv28aa_float"></span><span id="aa_float"></span><span class="target" id="aa_8h_1a6ab1ca62f04bdb4c63d1cea9cb89b36f"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">scs_float</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aa_float</span></span></span><a class="headerlink" href="#_CPPv48aa_float" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv46aa_int">
<span id="_CPPv36aa_int"></span><span id="_CPPv26aa_int"></span><span id="aa_int"></span><span class="target" id="aa_8h_1a518ce90ae9e4fcece7907247cd04d150"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="n"><span class="pre">scs_int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aa_int</span></span></span><a class="headerlink" href="#_CPPv46aa_int" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv46AaWork">
<span id="_CPPv36AaWork"></span><span id="_CPPv26AaWork"></span><span id="AaWork"></span><span class="target" id="aa_8h_1abccab62fbdd940ce82c2e250335d8bcb"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ACCEL_WORK</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">AaWork</span></span></span><a class="headerlink" href="#_CPPv46AaWork" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv47aa_init6aa_int6aa_int6aa_int8aa_float8aa_float8aa_float8aa_float6aa_int">
<span id="_CPPv37aa_init6aa_int6aa_int6aa_int8aa_float8aa_float8aa_float8aa_float6aa_int"></span><span id="_CPPv27aa_init6aa_int6aa_int6aa_int8aa_float8aa_float8aa_float8aa_float6aa_int"></span><span id="aa_init__aa_int.aa_int.aa_int.aa_float.aa_float.aa_float.aa_float.aa_int"></span><span class="target" id="aa_8h_1a6288bec767af6f27341a19c238d9b7ef"></span><a class="reference internal" href="#_CPPv46AaWork" title="AaWork"><span class="n"><span class="pre">AaWork</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">aa_init</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv46aa_int" title="aa_int"><span class="n"><span class="pre">aa_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">dim</span></span>, <a class="reference internal" href="#_CPPv46aa_int" title="aa_int"><span class="n"><span class="pre">aa_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">mem</span></span>, <a class="reference internal" href="#_CPPv46aa_int" title="aa_int"><span class="n"><span class="pre">aa_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">type1</span></span>, <a class="reference internal" href="#_CPPv48aa_float" title="aa_float"><span class="n"><span class="pre">aa_float</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">regularization</span></span>, <a class="reference internal" href="#_CPPv48aa_float" title="aa_float"><span class="n"><span class="pre">aa_float</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">relaxation</span></span>, <a class="reference internal" href="#_CPPv48aa_float" title="aa_float"><span class="n"><span class="pre">aa_float</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">safeguard_factor</span></span>, <a class="reference internal" href="#_CPPv48aa_float" title="aa_float"><span class="n"><span class="pre">aa_float</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">max_weight_norm</span></span>, <a class="reference internal" href="#_CPPv46aa_int" title="aa_int"><span class="n"><span class="pre">aa_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">verbosity</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv47aa_init6aa_int6aa_int6aa_int8aa_float8aa_float8aa_float8aa_float6aa_int" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initialize Anderson Acceleration, allocates memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> – the dimension of the variable for AA </p></li>
<li><p><strong>mem</strong> – the memory (number of past iterations used) for AA </p></li>
<li><p><strong>type1</strong> – if True use type 1 AA, otherwise use type 2 </p></li>
<li><p><strong>regularization</strong> – type-I and type-II different, for type-I: 1e-8 works well, type-II: more stable can use 1e-12 often </p></li>
<li><p><strong>relaxation</strong> – float \in [0,2], mixing parameter (1.0 is vanilla) </p></li>
<li><p><strong>safeguard_factor</strong> – factor that controls safeguarding checks larger is more aggressive but less stable </p></li>
<li><p><strong>max_weight_norm</strong> – float, maximum norm of AA weights </p></li>
<li><p><strong>verbosity</strong> – if greater than 0 prints out various info</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>pointer to AA workspace </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv48aa_applyP8aa_floatPK8aa_floatP6AaWork">
<span id="_CPPv38aa_applyP8aa_floatPK8aa_floatP6AaWork"></span><span id="_CPPv28aa_applyP8aa_floatPK8aa_floatP6AaWork"></span><span id="aa_apply__aa_floatP.aa_floatCP.AaWorkP"></span><span class="target" id="aa_8h_1addc105e961590f011f3989170cd975c6"></span><a class="reference internal" href="#_CPPv48aa_float" title="aa_float"><span class="n"><span class="pre">aa_float</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aa_apply</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48aa_float" title="aa_float"><span class="n"><span class="pre">aa_float</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv48aa_float" title="aa_float"><span class="n"><span class="pre">aa_float</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <a class="reference internal" href="#_CPPv46AaWork" title="AaWork"><span class="n"><span class="pre">AaWork</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48aa_applyP8aa_floatPK8aa_floatP6AaWork" title="Permalink to this definition"></a><br /></dt>
<dd><p>Apply Anderson Acceleration. The usage pattern should be as follows:</p>
<p><ul>
<li><p>for i = 0 .. N:<ul class="simple">
<li><p>if (i &gt; 0): aa_apply(x, x_prev, a)</p></li>
<li><p>x_prev = x.copy()</p></li>
<li><p>x = F(x)</p></li>
<li><p>aa_safeguard(x, x_prev, a) // optional but helps stability</p></li>
</ul>
</p>
<p>Here F is the map we are trying to find the fixed point for. We put the AA before the map so that any properties of the map are maintained at the end. Eg if the map contains a projection onto a set then the output is guaranteed to be in the set.</p>
</li>
</ul>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> – output of map at current iteration, overwritten with AA output </p></li>
<li><p><strong>x</strong> – input to map at current iteration </p></li>
<li><p><strong>a</strong> – workspace from aa_init</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(+ or -) norm of AA weights vector. If positive then update was accepted and f contains new point, if negative then update was rejected and f is unchanged </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412aa_safeguardP8aa_floatP8aa_floatP6AaWork">
<span id="_CPPv312aa_safeguardP8aa_floatP8aa_floatP6AaWork"></span><span id="_CPPv212aa_safeguardP8aa_floatP8aa_floatP6AaWork"></span><span id="aa_safeguard__aa_floatP.aa_floatP.AaWorkP"></span><span class="target" id="aa_8h_1a9aa1e1902cb1d80dc5ee809e6a88189a"></span><a class="reference internal" href="#_CPPv46aa_int" title="aa_int"><span class="n"><span class="pre">aa_int</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aa_safeguard</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv48aa_float" title="aa_float"><span class="n"><span class="pre">aa_float</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">f_new</span></span>, <a class="reference internal" href="#_CPPv48aa_float" title="aa_float"><span class="n"><span class="pre">aa_float</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x_new</span></span>, <a class="reference internal" href="#_CPPv46AaWork" title="AaWork"><span class="n"><span class="pre">AaWork</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412aa_safeguardP8aa_floatP8aa_floatP6AaWork" title="Permalink to this definition"></a><br /></dt>
<dd><p>Apply safeguarding.</p>
<p>This step is optional but can improve stability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f_new</strong> – output of map after AA step </p></li>
<li><p><strong>x_new</strong> – AA output that is input to the map </p></li>
<li><p><strong>a</strong> – workspace from aa_init</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 if AA step is accepted otherwise -1, if AA step is rejected then this overwrites f_new and x_new with previous values </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv49aa_finishP6AaWork">
<span id="_CPPv39aa_finishP6AaWork"></span><span id="_CPPv29aa_finishP6AaWork"></span><span id="aa_finish__AaWorkP"></span><span class="target" id="aa_8h_1a38824bbb8c9e9120bb703f5d177034ec"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aa_finish</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv46AaWork" title="AaWork"><span class="n"><span class="pre">AaWork</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49aa_finishP6AaWork" title="Permalink to this definition"></a><br /></dt>
<dd><p>Finish Anderson Acceleration, clears memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>a</strong> – AA workspace from aa_init </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv48aa_resetP6AaWork">
<span id="_CPPv38aa_resetP6AaWork"></span><span id="_CPPv28aa_resetP6AaWork"></span><span id="aa_reset__AaWorkP"></span><span class="target" id="aa_8h_1af838479f20a0a48b7484bfdbbca6c921"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aa_reset</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv46AaWork" title="AaWork"><span class="n"><span class="pre">AaWork</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48aa_resetP6AaWork" title="Permalink to this definition"></a><br /></dt>
<dd><p>Reset Anderson Acceleration.</p>
<p>Resets AA as if at the first iteration, reuses original memory allocations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>a</strong> – AA workspace from aa_init </p>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/scs_logo_transparent.png" alt="Logo"/>
    
  </a>
</p>










<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Algorithm</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="equilibration.html">Data equilibration</a></li>
<li class="toctree-l2"><a class="reference internal" href="scale.html">Non-identity DR Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="warm_start.html">Warm-starting</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Acceleration</a></li>
<li class="toctree-l2"><a class="reference internal" href="relaxation.html">Relaxation</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#optimality-conditions">Optimality conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#termination-criteria">Termination criteria</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/index.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../linear_solver/index.html">Linear System Solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../blas_lapack/index.html">BLAS and LAPACK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../help/index.html">Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citing/index.html">Citing SCS</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Algorithm</a><ul>
      <li>Previous: <a href="warm_start.html" title="previous chapter">Warm-starting</a></li>
      <li>Next: <a href="relaxation.html" title="next chapter">Relaxation</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Brendan O'Donoghue.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.3.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/algorithm/acceleration.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/cvxgrp/scs" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-203326834-1']);
      _gaq.push(['_setDomainName', 'none']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    
  </body>
</html>