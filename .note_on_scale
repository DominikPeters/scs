In this note we derive the update equations when using a non-identity scaling.
Solving LCP(M, q), using https://arxiv.org/pdf/2004.02177.pdf.

DR splitting is:

\tilde u^{k+1} = (I + F)^{-1} w^k
u^{k+1} = (I + G)^{-1} (2 \tilde u^{k+1} - w^k)
w^{k+1} = w^k + alpha * (u^{k+1} - \tilde u^{k+1})

yielding w^k \rightarrow u^\star + F(u^s\tar) where 0 \in F(u^\star) + G(u^\star).

Now consider diagonal matrix R instead of I, the above becomes:

\tilde u^{k+1} = (R + F)^{-1} R w^k
u^{k+1} = (R + G)^{-1} R (2 \tilde u^{k+1} - w^k)
w^{k+1} = w^k + alpha * (u^{k+1} - \tilde u^{k+1})

w^k \rightarrow u^\star + R^{-1} F(u^s\tar) where 0 \in F(u^\star) + G(u^\star).

In SCS, F = \mathcal{Q} and G = I_C. R has to be chosen so that the cone
projection is preserved. To do this we ensure that the entries of R > 0
corresponding to each cone are constant within that cone. This means that
R does not affect the cone projection in any way, since:

     x = (r I + \partial I_C)^{-1} (r y)
=>   0 \in r(x - y) + \partial I_C(x)
=> \min_x || x - y ||^2 s.t. x \in C.

We take R = [rho_x * I_n           0        0]
            [ 0           diag(rho_y_vec)   0]
            [ 0                    0        d]

where I_n is nxn identity, rho_x \in \reals, rho_y_vec \in \reals^m and d \in
\reals. The rho_y_vec term includes the effect of the parameter `scale', which
is updated heuristically to improve convergence. Let R_x = rho_x * I_n
and R_y = diag(rho_y_vec).

*Linear equation to be solved:

z = p^k - r tau, where
  p^k = (R + M)^{-1} R \mu^k     ** this is solved at every iteration
  r   = (R + M)^{-1} q           ** R does *not* appear before q here.      

Now consider z = (R + M)^{-1} R \mu

recall M = [ P   A']
           [-A   0 ]


so want to solve [z_x] = [R_x + P   A']^{-1} [q_x]
                 [z_y]   [  -A     R_y]      [q_y]

which is quasidefinite if we negate the bottom row:

                 [z_x] = [R_x + P   A']^{-1} [ q_x]
                 [z_y]   [  A     -R_y]      [-q_y]

A direct method factorizes the above matrix.

An indirect method can solve via:
           (R_x + P + A' R_y^{-1} A) z_x = q_x - A' R_y^{-1} q_y
                                     z_y = R_y^{-1}(A z_x + q_y).

*Obtaining the v^k = [r^k;s^k;kappa^k] vector:

v^{k+1} = R( u^{k+1} + w^k - 2 \tilde u^{k+1} ) \rightarrow F(u^\star)

*root_plus function:

tau^2 (d + r' R r) + tau (r' R \mu^k - 2 r' R p^k - d \eta^k) + p^k R (p^k - \mu^k) = 0

other than rsk (which does not affect the alg) this is the *only* place
where 'd' appears, so we have a lot of flexibility in how to choose it.
`d' is determined by `TAU_FACTOR' in the code.

(see the `dot_with_diag_scaling' function in src/scs.c).

*Projecting onto to the cone unaffacted (see previous discussion).
